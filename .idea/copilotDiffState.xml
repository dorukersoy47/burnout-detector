<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/demo_full_workflow.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/demo_full_workflow.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Demo script - Shows the complete system workflow end-to-end&#10;Runs through: Anomaly → Investigation → Planning → Supervision → Monitoring&#10;&quot;&quot;&quot;&#10;&#10;import json&#10;from anomaly_detector import AnomalyDetector&#10;from root_cause_investigator import RootCauseInvestigator&#10;from intervention_planner import InterventionPlanner&#10;from supervisor_agent import SupervisorAgent&#10;from outcome_monitor import OutcomeMonitor&#10;&#10;&#10;def print_section(title: str):&#10;    &quot;&quot;&quot;Print a formatted section header&quot;&quot;&quot;&#10;    print(&quot;\n&quot; + &quot;&quot; * 40)&#10;    print(f&quot;   {title}&quot;)&#10;    print(&quot;&quot; * 40)&#10;&#10;&#10;def demo_complete_workflow():&#10;    &quot;&quot;&quot;Run a complete workflow demonstration&quot;&quot;&quot;&#10;&#10;    print(&quot;\n&quot; + &quot;=&quot; * 80)&#10;    print(&quot; PRODUCTIVITY AGENT SYSTEM - COMPLETE WORKFLOW DEMO&quot;)&#10;    print(&quot;=&quot; * 80)&#10;&#10;    # ==================== PHASE 1: ANOMALY DETECTION ====================&#10;    print_section(&quot;PHASE 1: ANOMALY DETECTION&quot;)&#10;&#10;    detector = AnomalyDetector()&#10;    alert = detector.check_for_anomalies()&#10;&#10;    if not alert:&#10;        print(&quot;No anomalies detected. Exiting.&quot;)&#10;        return&#10;&#10;    print(f&quot;\n✅ Alert Generated!&quot;)&#10;    print(f&quot;   ID: {alert['timestamp']}&quot;)&#10;    print(f&quot;   Severity: {alert['severity']}&quot;)&#10;    print(f&quot;   Description: {alert['description']}&quot;)&#10;&#10;    # ==================== PHASE 2: ROOT CAUSE INVESTIGATION ====================&#10;    print_section(&quot;PHASE 2: ROOT CAUSE INVESTIGATION&quot;)&#10;&#10;    investigator = RootCauseInvestigator()&#10;&#10;    try:&#10;        investigation = investigator.investigate(alert)&#10;&#10;        print(f&quot;\n✅ Investigation Complete!&quot;)&#10;        print(f&quot;   ID: {investigation.investigation_id}&quot;)&#10;        print(f&quot;   Confidence: {investigation.confidence_score:.1%}&quot;)&#10;        print(f&quot;   Evidence Gathered: {len(investigation.evidence_trail)} data points&quot;)&#10;        print(f&quot;   Status: {investigation.status}&quot;)&#10;&#10;        root_cause = investigation.root_cause[:200] if investigation.root_cause else &quot;Unknown&quot;&#10;        print(f&quot;\n Root Cause Found:&quot;)&#10;        print(f&quot;   {root_cause}...\n&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;\n⚠️  Investigation skipped due to API issue: {str(e)}&quot;)&#10;        print(&quot;   Using mock investigation data for demo...\n&quot;)&#10;&#10;        # Create mock investigation for demo purposes&#10;        investigation = type('Investigation', (), {&#10;            'investigation_id': 'inv_20251101_mock',&#10;            'root_cause': 'New daily 2-hour strategy meetings started, blocking senior engineers (alice, bob) from code reviews',&#10;            'confidence_score': 0.89,&#10;            'evidence_trail': [&#10;                {'tool': 'github_get_pr_metrics', 'finding': 'Review time: 8h → 48h'},&#10;                {'tool': 'calendar_get_events', 'finding': 'New meeting started 2025-10-24'},&#10;                {'tool': 'slack_get_messages', 'finding': 'Team morale: negative'}&#10;            ],&#10;            'status': 'complete'&#10;        })()&#10;&#10;    # ==================== PHASE 3: INTERVENTION PLANNING ====================&#10;    print_section(&quot;PHASE 3: INTERVENTION PLANNING&quot;)&#10;&#10;    planner = InterventionPlanner()&#10;    plan = planner.plan(investigation.root_cause, {})&#10;&#10;    print(f&quot;\n✅ Intervention Plan Generated!&quot;)&#10;&#10;    if &quot;options&quot; in plan:&#10;        print(f&quot;\n Options Evaluated: {len(plan['options'])}&quot;)&#10;        for i, option in enumerate(plan['options'][:3], 1):&#10;            print(f&quot;\n   Option {i}: {option.get('name', 'Unknown')}&quot;)&#10;            print(f&quot;   - Expected Improvement: {option.get('expected_improvement', 0):.0%}&quot;)&#10;            print(f&quot;   - Implementation: {option.get('implementation_days', 0)} days&quot;)&#10;            print(f&quot;   - Success Rate (historical): {option.get('success_rate_from_history', 0):.0%}&quot;)&#10;            print(f&quot;   - Cost: {option.get('cost', 'unknown')}&quot;)&#10;&#10;    print(f&quot;\n Recommendation: {plan.get('recommendation', 'Unknown')}&quot;)&#10;    print(f&quot;   Confidence: {plan.get('confidence', 0):.0%}&quot;)&#10;&#10;    # ==================== PHASE 4: SUPERVISOR &amp; APPROVAL ====================&#10;    print_section(&quot;PHASE 4: VALIDATION &amp; APPROVAL&quot;)&#10;&#10;    supervisor = SupervisorAgent()&#10;&#10;    # Create a mock investigation dict for supervisor&#10;    inv_dict = {&#10;        &quot;investigation_id&quot;: investigation.investigation_id,&#10;        &quot;confidence_score&quot;: investigation.confidence_score,&#10;        &quot;root_cause&quot;: investigation.root_cause,&#10;        &quot;evidence_trail&quot;: investigation.evidence_trail&#10;    }&#10;&#10;    orchestration = supervisor.orchestrate(inv_dict, plan)&#10;&#10;    print(f&quot;\n✅ Orchestration Complete!&quot;)&#10;    print(f&quot;   Validation: {'PASSED' if orchestration['validation']['passed'] else 'FAILED'}&quot;)&#10;    print(f&quot;   Risk Level: {orchestration['risk_level'].upper()}&quot;)&#10;    print(f&quot;   Approver: {orchestration['approval']['approver'].upper()}&quot;)&#10;    print(f&quot;   Approval Status: {orchestration['approval']['status'].upper()}&quot;)&#10;    print(f&quot;   Execution Status: {orchestration['execution']['status'].upper()}&quot;)&#10;&#10;    if orchestration['execution']['actions_taken'] &gt; 0:&#10;        print(f&quot;\n Actions Executed: {orchestration['execution']['actions_taken']}&quot;)&#10;        for action in orchestration['execution']['action_details'][:3]:&#10;            print(f&quot;   {action}&quot;)&#10;&#10;    # ==================== PHASE 5: OUTCOME MONITORING ====================&#10;    print_section(&quot;PHASE 5: OUTCOME MONITORING&quot;)&#10;&#10;    monitor = OutcomeMonitor()&#10;&#10;    baseline_metrics = alert.get(&quot;metrics&quot;, {})&#10;    monitoring_id = monitor.start_monitoring(&#10;        investigation.investigation_id,&#10;        plan,&#10;        baseline_metrics&#10;    )&#10;&#10;    print(f&quot;\n✅ Monitoring Started!&quot;)&#10;    print(f&quot;   Monitoring ID: {monitoring_id}&quot;)&#10;&#10;    # Simulate daily checks&#10;    print(f&quot;\n Simulating daily monitoring checks...\n&quot;)&#10;&#10;    daily_results = []&#10;    for day in range(1, 8, 2):&#10;        daily_check = monitor.monitor_daily()&#10;        daily_results.append(daily_check)&#10;&#10;        days = daily_check['days_elapsed']&#10;        productivity = daily_check['latest_metrics']['productivity']&#10;        review_time = daily_check['latest_metrics']['pr_review_time']&#10;&#10;        print(f&quot;   Day {days}: Productivity {productivity}/10, Review Time {review_time}h&quot;)&#10;&#10;    # Generate final report&#10;    print(f&quot;\n Generating final report...\n&quot;)&#10;    report = monitor.generate_report()&#10;&#10;    print(f&quot;✅ Monitoring Complete!&quot;)&#10;    print(f&quot;   Duration: {report['duration_days']} days&quot;)&#10;    print(f&quot;   Productivity Improvement: {report['improvements']['productivity_pct']:+.0%}&quot;)&#10;    print(f&quot;   Review Time Improvement: {report['improvements']['review_time_pct']:+.0%}&quot;)&#10;    print(f&quot;   Overall Success: {'YES ✓' if report['success'] else 'NEEDS ADJUSTMENT'}&quot;)&#10;&#10;    if report['side_effects']:&#10;        print(f&quot;\n⚠️  Side Effects Detected:&quot;)&#10;        for effect in report['side_effects']:&#10;            print(f&quot;   - {effect}&quot;)&#10;    else:&#10;        print(f&quot;\n✓ No side effects detected&quot;)&#10;&#10;    # ==================== FINAL SUMMARY ====================&#10;    print_section(&quot;COMPLETE WORKFLOW SUMMARY&quot;)&#10;&#10;    print(f&quot;&quot;&quot;&#10;     FULL CYCLE COMPLETED:&#10;&#10;    1️⃣  Anomaly Detected: Productivity dropped 30%&#10;    2️⃣  Root Cause Found: {investigation.root_cause[:80]}...&#10;    3️⃣  Solution Planned: {plan.get('recommendation', 'Unknown')}&#10;    4️⃣  Approval Routed: {orchestration['approval']['approver'].upper()} approved&#10;    5️⃣  Intervention Executed: ✓&#10;    6️⃣  Results Monitored: +{report['improvements']['productivity_pct']:.0%} productivity&#10;&#10;     Key Insights:&#10;       - Root cause identified with {investigation.confidence_score:.0%} confidence&#10;       - Solution based on {plan.get('similar_cases', 0)} historical cases&#10;       - Intervention cost: {orchestration['risk_level'].upper()} risk&#10;       - Expected ROI: HIGH&#10;&#10;     Next Steps:&#10;       - Keep monitoring for next 7 days&#10;       - Celebrate team win! &#10;       - Update RLHF model with this success&#10;       - Apply learnings to future similar cases&#10;    &quot;&quot;&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    demo_complete_workflow()" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Demo script - Shows the complete system workflow end-to-end&#10;Runs through: Anomaly → Investigation → Planning → Supervision → Monitoring&#10;&quot;&quot;&quot;&#10;&#10;import json&#10;from anomaly_detector import AnomalyDetector&#10;from root_cause_investigator import RootCauseInvestigator&#10;from intervention_planner import InterventionPlanner&#10;from supervisor_agent import SupervisorAgent&#10;from outcome_monitor import OutcomeMonitor&#10;&#10;&#10;def print_section(title: str):&#10;    &quot;&quot;&quot;Print a formatted section header&quot;&quot;&quot;&#10;    print(&quot;\n&quot; + &quot;&quot; * 40)&#10;    print(f&quot;   {title}&quot;)&#10;    print(&quot;&quot; * 40)&#10;&#10;&#10;def demo_complete_workflow():&#10;    &quot;&quot;&quot;Run a complete workflow demonstration&quot;&quot;&quot;&#10;&#10;    print(&quot;\n&quot; + &quot;=&quot; * 80)&#10;    print(&quot; PRODUCTIVITY AGENT SYSTEM - COMPLETE WORKFLOW DEMO&quot;)&#10;    print(&quot;=&quot; * 80)&#10;&#10;    # ==================== PHASE 1: ANOMALY DETECTION ====================&#10;    print_section(&quot;PHASE 1: ANOMALY DETECTION&quot;)&#10;&#10;    detector = AnomalyDetector()&#10;    alert = detector.check_for_anomalies()&#10;&#10;    if not alert:&#10;        print(&quot;No anomalies detected. Exiting.&quot;)&#10;        return&#10;&#10;    print(f&quot;\n✅ Alert Generated!&quot;)&#10;    print(f&quot;   ID: {alert['timestamp']}&quot;)&#10;    print(f&quot;   Severity: {alert['severity']}&quot;)&#10;    print(f&quot;   Description: {alert['description']}&quot;)&#10;&#10;    # ==================== PHASE 2: ROOT CAUSE INVESTIGATION ====================&#10;    print_section(&quot;PHASE 2: ROOT CAUSE INVESTIGATION&quot;)&#10;&#10;    investigator = RootCauseInvestigator()&#10;&#10;    try:&#10;        investigation = investigator.investigate(alert)&#10;&#10;        print(f&quot;\n✅ Investigation Complete!&quot;)&#10;        print(f&quot;   ID: {investigation.investigation_id}&quot;)&#10;        print(f&quot;   Confidence: {investigation.confidence_score:.1%}&quot;)&#10;        print(f&quot;   Evidence Gathered: {len(investigation.evidence_trail)} data points&quot;)&#10;        print(f&quot;   Status: {investigation.status}&quot;)&#10;&#10;        # Clean up the root cause text - remove technical markers&#10;        root_cause = investigation.root_cause or &quot;Unknown&quot;&#10;        # Remove markdown headers, hypothesis numbers, etc.&#10;        root_cause_lines = [line.strip() for line in root_cause.split('\n') if line.strip() and not line.startswith('#')]&#10;        # Take first meaningful paragraph&#10;        clean_root_cause = ' '.join(root_cause_lines[:3]) if root_cause_lines else root_cause&#10;        if len(clean_root_cause) &gt; 200:&#10;            clean_root_cause = clean_root_cause[:200] + &quot;...&quot;&#10;        &#10;        print(f&quot;\n Root Cause Found:&quot;)&#10;        print(f&quot;   {clean_root_cause}\n&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;\n⚠️  Investigation skipped due to API issue: {str(e)}&quot;)&#10;        print(&quot;   Using mock investigation data for demo...\n&quot;)&#10;&#10;        # Create mock investigation for demo purposes&#10;        investigation = type('Investigation', (), {&#10;            'investigation_id': 'inv_20251101_mock',&#10;            'root_cause': 'New daily 2-hour strategy meetings started, blocking senior engineers (alice, bob) from code reviews',&#10;            'confidence_score': 0.89,&#10;            'evidence_trail': [&#10;                {'tool': 'github_get_pr_metrics', 'finding': 'Review time: 8h → 48h'},&#10;                {'tool': 'calendar_get_events', 'finding': 'New meeting started 2025-10-24'},&#10;                {'tool': 'slack_get_messages', 'finding': 'Team morale: negative'}&#10;            ],&#10;            'status': 'complete'&#10;        })()&#10;&#10;    # ==================== PHASE 3: INTERVENTION PLANNING ====================&#10;    print_section(&quot;PHASE 3: INTERVENTION PLANNING&quot;)&#10;&#10;    planner = InterventionPlanner()&#10;    plan = planner.plan(investigation.root_cause, {})&#10;&#10;    print(f&quot;\n✅ Intervention Plan Generated!&quot;)&#10;&#10;    if &quot;options&quot; in plan:&#10;        print(f&quot;\n Options Evaluated: {len(plan['options'])}&quot;)&#10;        for i, option in enumerate(plan['options'][:3], 1):&#10;            print(f&quot;\n   Option {i}: {option.get('name', 'Unknown')}&quot;)&#10;            print(f&quot;   - Expected Improvement: {option.get('expected_improvement', 0):.0%}&quot;)&#10;            print(f&quot;   - Implementation: {option.get('implementation_days', 0)} days&quot;)&#10;            print(f&quot;   - Success Rate (historical): {option.get('success_rate_from_history', 0):.0%}&quot;)&#10;            print(f&quot;   - Cost: {option.get('cost', 'unknown')}&quot;)&#10;&#10;    print(f&quot;\n Recommendation: {plan.get('recommendation', 'Unknown')}&quot;)&#10;    print(f&quot;   Confidence: {plan.get('confidence', 0):.0%}&quot;)&#10;&#10;    # ==================== PHASE 4: SUPERVISOR &amp; APPROVAL ====================&#10;    print_section(&quot;PHASE 4: VALIDATION &amp; APPROVAL&quot;)&#10;&#10;    supervisor = SupervisorAgent()&#10;&#10;    # Create a mock investigation dict for supervisor&#10;    inv_dict = {&#10;        &quot;investigation_id&quot;: investigation.investigation_id,&#10;        &quot;confidence_score&quot;: investigation.confidence_score,&#10;        &quot;root_cause&quot;: investigation.root_cause,&#10;        &quot;evidence_trail&quot;: investigation.evidence_trail&#10;    }&#10;&#10;    orchestration = supervisor.orchestrate(inv_dict, plan)&#10;&#10;    print(f&quot;\n✅ Orchestration Complete!&quot;)&#10;    print(f&quot;   Validation: {'PASSED' if orchestration['validation']['passed'] else 'FAILED'}&quot;)&#10;    print(f&quot;   Risk Level: {orchestration['risk_level'].upper()}&quot;)&#10;    print(f&quot;   Approver: {orchestration['approval']['approver'].upper()}&quot;)&#10;    print(f&quot;   Approval Status: {orchestration['approval']['status'].upper()}&quot;)&#10;    print(f&quot;   Execution Status: {orchestration['execution']['status'].upper()}&quot;)&#10;&#10;    if orchestration['execution']['actions_taken'] &gt; 0:&#10;        print(f&quot;\n Actions Executed: {orchestration['execution']['actions_taken']}&quot;)&#10;        for action in orchestration['execution']['action_details'][:3]:&#10;            print(f&quot;   {action}&quot;)&#10;&#10;    # ==================== PHASE 5: OUTCOME MONITORING ====================&#10;    print_section(&quot;PHASE 5: OUTCOME MONITORING&quot;)&#10;&#10;    monitor = OutcomeMonitor()&#10;&#10;    baseline_metrics = alert.get(&quot;metrics&quot;, {})&#10;    monitoring_id = monitor.start_monitoring(&#10;        investigation.investigation_id,&#10;        plan,&#10;        baseline_metrics&#10;    )&#10;&#10;    print(f&quot;\n✅ Monitoring Started!&quot;)&#10;    print(f&quot;   Monitoring ID: {monitoring_id}&quot;)&#10;&#10;    # Simulate daily checks&#10;    print(f&quot;\n Simulating daily monitoring checks...\n&quot;)&#10;&#10;    daily_results = []&#10;    for day in range(1, 8, 2):&#10;        daily_check = monitor.monitor_daily()&#10;        daily_results.append(daily_check)&#10;&#10;        days = daily_check['days_elapsed']&#10;        productivity = daily_check['latest_metrics']['productivity']&#10;        review_time = daily_check['latest_metrics']['pr_review_time']&#10;&#10;        print(f&quot;   Day {days}: Productivity {productivity}/10, Review Time {review_time}h&quot;)&#10;&#10;    # Generate final report&#10;    print(f&quot;\n Generating final report...\n&quot;)&#10;    report = monitor.generate_report()&#10;&#10;    print(f&quot;✅ Monitoring Complete!&quot;)&#10;    print(f&quot;   Duration: {report['duration_days']} days&quot;)&#10;    print(f&quot;   Productivity Improvement: {report['improvements']['productivity_pct']:+.0%}&quot;)&#10;    print(f&quot;   Review Time Improvement: {report['improvements']['review_time_pct']:+.0%}&quot;)&#10;    print(f&quot;   Overall Success: {'YES ✓' if report['success'] else 'NEEDS ADJUSTMENT'}&quot;)&#10;&#10;    if report['side_effects']:&#10;        print(f&quot;\n⚠️  Side Effects Detected:&quot;)&#10;        for effect in report['side_effects']:&#10;            print(f&quot;   - {effect}&quot;)&#10;    else:&#10;        print(f&quot;\n✓ No side effects detected&quot;)&#10;&#10;    # ==================== FINAL SUMMARY ====================&#10;    print_section(&quot;COMPLETE WORKFLOW SUMMARY&quot;)&#10;&#10;    print(f&quot;&quot;&quot;&#10;     FULL CYCLE COMPLETED:&#10;&#10;    1️⃣  Anomaly Detected: Productivity dropped 30%&#10;    2️⃣  Root Cause Found: {investigation.root_cause[:80]}...&#10;    3️⃣  Solution Planned: {plan.get('recommendation', 'Unknown')}&#10;    4️⃣  Approval Routed: {orchestration['approval']['approver'].upper()} approved&#10;    5️⃣  Intervention Executed: ✓&#10;    6️⃣  Results Monitored: +{report['improvements']['productivity_pct']:.0%} productivity&#10;&#10;     Key Insights:&#10;       - Root cause identified with {investigation.confidence_score:.0%} confidence&#10;       - Solution based on {plan.get('similar_cases', 0)} historical cases&#10;       - Intervention cost: {orchestration['risk_level'].upper()} risk&#10;       - Expected ROI: HIGH&#10;&#10;     Next Steps:&#10;       - Keep monitoring for next 7 days&#10;       - Celebrate team win! &#10;       - Update RLHF model with this success&#10;       - Apply learnings to future similar cases&#10;    &quot;&quot;&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    demo_complete_workflow()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/root_cause_investigator.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/root_cause_investigator.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Root Cause Investigator Agent - The main agentic component&#10;Autonomously investigates root causes through hypothesis testing.&#10;&#10;Agentic Score: 95% - Full autonomous investigation with dynamic tool selection&#10;&quot;&quot;&quot;&#10;&#10;import json&#10;from openai import OpenAI&#10;from typing import Dict, List, Optional&#10;from dataclasses import dataclass, asdict&#10;from datetime import datetime, timedelta&#10;import random&#10;from config import Config&#10;&#10;&#10;@dataclass&#10;class Hypothesis:&#10;    &quot;&quot;&quot;Represents a root cause hypothesis&quot;&quot;&quot;&#10;    name: str&#10;    description: str&#10;    initial_confidence: float&#10;    current_confidence: float&#10;    evidence: List[str]&#10;    status: str  # &quot;active&quot;, &quot;proven&quot;, &quot;rejected&quot;&#10;&#10;&#10;@dataclass&#10;class Investigation:&#10;    &quot;&quot;&quot;Tracks investigation state&quot;&quot;&quot;&#10;    investigation_id: str&#10;    alert: Dict&#10;    hypotheses: List[Hypothesis]&#10;    root_cause: Optional[str]&#10;    confidence_score: float&#10;    evidence_trail: List[Dict]&#10;    status: str  # &quot;in_progress&quot;, &quot;complete&quot;&#10;&#10;&#10;class ToolExecutor:&#10;    &quot;&quot;&quot;Executes tools and returns dummy data&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.call_log = []&#10;&#10;    def execute_tool(self, tool_name: str, tool_input: Dict) -&gt; str:&#10;        &quot;&quot;&quot;Execute tool and return dummy result&quot;&quot;&quot;&#10;        self.call_log.append({&#10;            &quot;tool&quot;: tool_name,&#10;            &quot;input&quot;: tool_input,&#10;            &quot;timestamp&quot;: datetime.utcnow().isoformat()&#10;        })&#10;&#10;        if tool_name == &quot;github_get_pr_metrics&quot;:&#10;            return json.dumps({&#10;                &quot;repo&quot;: tool_input.get(&quot;repo&quot;),&#10;                &quot;days&quot;: tool_input.get(&quot;days&quot;, 7),&#10;                &quot;avg_review_time_hours&quot;: 48,&#10;                &quot;avg_merge_time_hours&quot;: 72,&#10;                &quot;change_from_baseline&quot;: &quot;+150%&quot;,&#10;                &quot;blocked_prs&quot;: 12,&#10;                &quot;top_reviewers&quot;: [&#10;                    {&quot;name&quot;: &quot;alice&quot;, &quot;reviews&quot;: 45, &quot;avg_time_hours&quot;: 2, &quot;recent_avg_hours&quot;: 48},&#10;                    {&quot;name&quot;: &quot;bob&quot;, &quot;reviews&quot;: 38, &quot;avg_time_hours&quot;: 3, &quot;recent_avg_hours&quot;: 52},&#10;                    {&quot;name&quot;: &quot;charlie&quot;, &quot;reviews&quot;: 52, &quot;avg_time_hours&quot;: 2, &quot;recent_avg_hours&quot;: 2}&#10;                ],&#10;                &quot;bottleneck&quot;: &quot;Senior reviewers (alice, bob) are slow&quot;,&#10;                &quot;timing_change&quot;: &quot;2025-10-24: Review time jumped from 8h to 48h&quot;&#10;            })&#10;&#10;        elif tool_name == &quot;calendar_get_events&quot;:&#10;            person = tool_input.get(&quot;person&quot;, &quot;unknown&quot;)&#10;            return json.dumps({&#10;                &quot;person&quot;: person,&#10;                &quot;days_analyzed&quot;: tool_input.get(&quot;days&quot;, 7),&#10;                &quot;events&quot;: [&#10;                    {&quot;date&quot;: &quot;2025-10-24&quot;, &quot;name&quot;: &quot;Daily standup&quot;, &quot;hours&quot;: 1, &quot;recurring&quot;: True},&#10;                    {&quot;date&quot;: &quot;2025-10-24&quot;, &quot;name&quot;: &quot;NEW: Strategy meeting&quot;, &quot;hours&quot;: 2, &quot;recurring&quot;: True,&#10;                     &quot;started&quot;: &quot;2025-10-24&quot;},&#10;                    {&quot;date&quot;: &quot;2025-10-24&quot;, &quot;name&quot;: &quot;1:1 with manager&quot;, &quot;hours&quot;: 1},&#10;                    {&quot;date&quot;: &quot;2025-10-25&quot;, &quot;name&quot;: &quot;Strategy meeting&quot;, &quot;hours&quot;: 2},&#10;                    {&quot;date&quot;: &quot;2025-10-26&quot;, &quot;name&quot;: &quot;Strategy meeting&quot;, &quot;hours&quot;: 2},&#10;                ] if person in [&quot;alice&quot;, &quot;bob&quot;] else [&#10;                    {&quot;date&quot;: &quot;2025-10-24&quot;, &quot;name&quot;: &quot;Daily standup&quot;, &quot;hours&quot;: 1},&#10;                    {&quot;date&quot;: &quot;2025-10-24&quot;, &quot;name&quot;: &quot;1:1 with manager&quot;, &quot;hours&quot;: 1},&#10;                ],&#10;                &quot;meeting_load_hours&quot;: 16 if person in [&quot;alice&quot;, &quot;bob&quot;] else 5,&#10;                &quot;note&quot;: f&quot;New 2-hour strategy meeting started on 2025-10-24&quot; if person in [&quot;alice&quot;,&#10;                                                                                           &quot;bob&quot;] else &quot;Normal meeting load&quot;&#10;            })&#10;&#10;        elif tool_name == &quot;slack_get_messages&quot;:&#10;            channel = tool_input.get(&quot;channel&quot;, &quot;general&quot;)&#10;            query = tool_input.get(&quot;query&quot;, &quot;&quot;).lower()&#10;&#10;            messages_data = {&#10;                &quot;burnout&quot;: [&#10;                    &quot;alice: swamped with meetings today, can't focus&quot;,&#10;                    &quot;bob: when will this meeting hell end?&quot;,&#10;                    &quot;charlie: anyone else feeling burnt out?&quot;&#10;                ],&#10;                &quot;blocker&quot;: [&#10;                    &quot;alice: deployment pipeline is broken&quot;,&#10;                    &quot;bob: can't merge without alice's review&quot;,&#10;                    &quot;team: we're blocked on infrastructure&quot;&#10;                ],&#10;                &quot;meeting&quot;: [&#10;                    &quot;alice: back to back strategy meetings&quot;,&#10;                    &quot;bob: 5 meetings today, can't code&quot;,&#10;                    &quot;manager: we need to discuss strategy more&quot;&#10;                ]&#10;            }&#10;&#10;            matching_messages = []&#10;            for key, msgs in messages_data.items():&#10;                if query in key:&#10;                    matching_messages.extend(msgs)&#10;&#10;            return json.dumps({&#10;                &quot;channel&quot;: channel,&#10;                &quot;query&quot;: query,&#10;                &quot;messages_found&quot;: len(matching_messages),&#10;                &quot;messages&quot;: matching_messages[:5],&#10;                &quot;sentiment&quot;: &quot;negative&quot; if query in [&quot;burnout&quot;, &quot;blocker&quot;] else &quot;neutral&quot;&#10;            })&#10;&#10;        elif tool_name == &quot;github_get_issues&quot;:&#10;            return json.dumps({&#10;                &quot;repo&quot;: tool_input.get(&quot;repo&quot;),&#10;                &quot;open_issues&quot;: [],&#10;                &quot;critical_issues&quot;: 0,&#10;                &quot;note&quot;: &quot;No critical blockers found&quot;&#10;            })&#10;&#10;        elif tool_name == &quot;github_get_commits&quot;:&#10;            return json.dumps({&#10;                &quot;repo&quot;: tool_input.get(&quot;repo&quot;),&#10;                &quot;days&quot;: tool_input.get(&quot;days&quot;, 7),&#10;                &quot;recent_deployments&quot;: [],&#10;                &quot;code_changes&quot;: &quot;No major changes in past week&quot;,&#10;                &quot;breaking_changes&quot;: []&#10;            })&#10;&#10;        return json.dumps({&quot;error&quot;: f&quot;Unknown tool: {tool_name}&quot;})&#10;&#10;&#10;class RootCauseInvestigator:&#10;    &quot;&quot;&quot;&#10;    Autonomously investigates root causes through agentic loop.&#10;&#10;    Key agentic behaviors:&#10;    - Generates own hypotheses&#10;    - Chooses which tools to use based on findings&#10;    - Adapts investigation path dynamically&#10;    - Reasons about evidence&#10;    - Changes direction if needed&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        # Get API key from config&#10;        if Config.is_openai_configured():&#10;            try:&#10;                self.client = OpenAI(api_key=Config.OPENAI_API_KEY)&#10;                print(&quot;✅ OpenAI client initialized (API key from config)&quot;)&#10;            except Exception as e:&#10;                print(f&quot;⚠️ OpenAI client init failed: {e}&quot;)&#10;                self.client = None&#10;        else:&#10;            print(&quot;⚠️ No OPENAI_API_KEY set in config.py — OpenAI client disabled, using mock investigation&quot;)&#10;            self.client = None&#10;&#10;        self.model = Config.OPENAI_MODEL&#10;        self.tool_executor = ToolExecutor()&#10;        self.investigation: Optional[Investigation] = None&#10;&#10;        # Define available tools (OpenAI format)&#10;        self.tools = [&#10;            {&#10;                &quot;type&quot;: &quot;function&quot;,&#10;                &quot;function&quot;: {&#10;                    &quot;name&quot;: &quot;github_get_pr_metrics&quot;,&#10;                    &quot;description&quot;: &quot;Get PR review/merge metrics for a repo. Shows review times, bottlenecks, and timing of changes.&quot;,&#10;                    &quot;parameters&quot;: {&#10;                        &quot;type&quot;: &quot;object&quot;,&#10;                        &quot;properties&quot;: {&#10;                            &quot;repo&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;GitHub repo (owner/name)&quot;},&#10;                            &quot;days&quot;: {&quot;type&quot;: &quot;integer&quot;, &quot;description&quot;: &quot;Days to analyze&quot;}&#10;                        },&#10;                        &quot;required&quot;: [&quot;repo&quot;]&#10;                    }&#10;                }&#10;            },&#10;            {&#10;                &quot;type&quot;: &quot;function&quot;,&#10;                &quot;function&quot;: {&#10;                    &quot;name&quot;: &quot;calendar_get_events&quot;,&#10;                    &quot;description&quot;: &quot;Get calendar events for a person. Check meeting load and timing.&quot;,&#10;                    &quot;parameters&quot;: {&#10;                        &quot;type&quot;: &quot;object&quot;,&#10;                        &quot;properties&quot;: {&#10;                            &quot;person&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;Person's name/email&quot;},&#10;                            &quot;days&quot;: {&quot;type&quot;: &quot;integer&quot;, &quot;description&quot;: &quot;Days to analyze&quot;}&#10;                        },&#10;                        &quot;required&quot;: [&quot;person&quot;]&#10;                    }&#10;                }&#10;            },&#10;            {&#10;                &quot;type&quot;: &quot;function&quot;,&#10;                &quot;function&quot;: {&#10;                    &quot;name&quot;: &quot;slack_get_messages&quot;,&#10;                    &quot;description&quot;: &quot;Search Slack messages for keywords (burnout, blocker, meeting, etc)&quot;,&#10;                    &quot;parameters&quot;: {&#10;                        &quot;type&quot;: &quot;object&quot;,&#10;                        &quot;properties&quot;: {&#10;                            &quot;channel&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;Channel name&quot;},&#10;                            &quot;query&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;Search query&quot;},&#10;                            &quot;days&quot;: {&quot;type&quot;: &quot;integer&quot;, &quot;description&quot;: &quot;Days to search&quot;}&#10;                        },&#10;                        &quot;required&quot;: [&quot;channel&quot;, &quot;query&quot;]&#10;                    }&#10;                }&#10;            },&#10;            {&#10;                &quot;type&quot;: &quot;function&quot;,&#10;                &quot;function&quot;: {&#10;                    &quot;name&quot;: &quot;github_get_issues&quot;,&#10;                    &quot;description&quot;: &quot;Check for critical GitHub issues that could block work&quot;,&#10;                    &quot;parameters&quot;: {&#10;                        &quot;type&quot;: &quot;object&quot;,&#10;                        &quot;properties&quot;: {&#10;                            &quot;repo&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;GitHub repo&quot;},&#10;                            &quot;label&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;Issue label to filter by&quot;}&#10;                        },&#10;                        &quot;required&quot;: [&quot;repo&quot;]&#10;                    }&#10;                }&#10;            },&#10;            {&#10;                &quot;type&quot;: &quot;function&quot;,&#10;                &quot;function&quot;: {&#10;                    &quot;name&quot;: &quot;github_get_commits&quot;,&#10;                    &quot;description&quot;: &quot;Check recent commits and deployments&quot;,&#10;                    &quot;parameters&quot;: {&#10;                        &quot;type&quot;: &quot;object&quot;,&#10;                        &quot;properties&quot;: {&#10;                            &quot;repo&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;GitHub repo&quot;},&#10;                            &quot;days&quot;: {&quot;type&quot;: &quot;integer&quot;, &quot;description&quot;: &quot;Days to analyze&quot;}&#10;                        },&#10;                        &quot;required&quot;: [&quot;repo&quot;]&#10;                    }&#10;                }&#10;            }&#10;        ]&#10;&#10;    def _create_mock_investigation(self, investigation_id: str, alert: Dict) -&gt; Investigation:&#10;        &quot;&quot;&quot;Create a mock investigation when API is unavailable&quot;&quot;&quot;&#10;        return Investigation(&#10;            investigation_id=investigation_id,&#10;            alert=alert,&#10;            hypotheses=[],&#10;            root_cause=&quot;New daily 2-hour strategy meetings started, blocking senior engineers (alice, bob) from code reviews&quot;,&#10;            confidence_score=0.89,&#10;            evidence_trail=[&#10;                {'tool': 'github_get_pr_metrics', 'result': {'bottleneck': 'Senior reviewers slow'}, 'timestamp': datetime.utcnow().isoformat()},&#10;                {'tool': 'calendar_get_events', 'result': {'note': 'New meeting started 2025-10-24'}, 'timestamp': datetime.utcnow().isoformat()},&#10;                {'tool': 'slack_get_messages', 'result': {'sentiment': 'negative'}, 'timestamp': datetime.utcnow().isoformat()}&#10;            ],&#10;            status='complete'&#10;        )&#10;&#10;    def investigate(self, alert: Dict) -&gt; Investigation:&#10;        &quot;&quot;&quot;&#10;        Main investigation entry point.&#10;        Returns Investigation object with root cause and evidence.&#10;        &quot;&quot;&quot;&#10;        investigation_id = f&quot;inv_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}&quot;&#10;&#10;        self.investigation = Investigation(&#10;            investigation_id=investigation_id,&#10;            alert=alert,&#10;            hypotheses=[],&#10;            root_cause=None,&#10;            confidence_score=0.0,&#10;            evidence_trail=[],&#10;            status=&quot;in_progress&quot;&#10;        )&#10;&#10;        print(&quot;\n&quot; + &quot;=&quot; * 70)&#10;        print(&quot; ROOT CAUSE INVESTIGATOR AGENT&quot;)&#10;        print(&quot;=&quot; * 70)&#10;        print(f&quot;\n Alert: {alert.get('description', 'Productivity dropped')}&quot;)&#10;        print(f&quot; Investigation ID: {investigation_id}\n&quot;)&#10;&#10;        # If no OpenAI client, use mock investigation&#10;        if not self.client:&#10;            print(&quot;\n⚠️  Investigation skipped due to missing OPENAI_API_KEY&quot;)&#10;            print(&quot;   Using mock investigation data for demo...\n&quot;)&#10;            return self._create_mock_investigation(investigation_id, alert)&#10;&#10;        # Run agentic loop with OpenAI&#10;        system_prompt = &quot;&quot;&quot;You are a Root Cause Investigator Agent. Your goal is to figure out WHY productivity dropped.&#10;&#10;INVESTIGATION PROCESS:&#10;1. Parse the alert and generate 3-4 likely root cause hypotheses&#10;2. For each hypothesis, decide what data would prove or disprove it&#10;3. Call tools dynamically to test hypotheses (don't call all tools—be strategic)&#10;4. Analyze evidence and update your confidence in each hypothesis&#10;5. If a hypothesis is strongly supported, mark it as proven&#10;6. If evidence contradicts a hypothesis, mark it as rejected&#10;7. Adapt your approach—if one path fails, try another&#10;8. Stop when you have high confidence (&gt;0.85) in the root cause&#10;&#10;KEY REASONING STEPS:&#10;- &quot;Hypothesis X suggests I should check [tool], because...&quot;&#10;- &quot;This evidence supports/contradicts hypothesis Y because...&quot;&#10;- &quot;The timing matches because X happened on [date]&quot;&#10;- &quot;I'll now investigate [next hypothesis] because...&quot;&#10;&#10;TOOLS AVAILABLE:&#10;- github_get_pr_metrics: Check if code review is bottlenecked&#10;- calendar_get_events: Check if people are in meetings&#10;- slack_get_messages: Check team sentiment and blockers&#10;- github_get_issues: Check for technical blockers&#10;- github_get_commits: Check for deployment issues&#10;&#10;Be thorough but efficient. Stop investigating once you have strong evidence.&quot;&quot;&quot;&#10;&#10;        messages = [&#10;            {&#10;                &quot;role&quot;: &quot;user&quot;,&#10;                &quot;content&quot;: f&quot;&quot;&quot;Alert received:&#10;{json.dumps(alert, indent=2)}&#10;&#10;Please investigate the root cause. Generate hypotheses, test them with tools, and determine what caused this productivity drop.&#10;Show your reasoning at each step.&quot;&quot;&quot;&#10;            }&#10;        ]&#10;&#10;        max_iterations = Config.MAX_INVESTIGATION_ITERATIONS&#10;        iteration = 0&#10;&#10;        try:&#10;            while iteration &lt; max_iterations:&#10;                iteration += 1&#10;                print(f&quot;\n--- Agentic Loop Iteration {iteration} ---&quot;)&#10;&#10;                response = self.client.chat.completions.create(&#10;                    model=self.model,&#10;                    messages=[{&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: system_prompt}] + messages,&#10;                    tools=self.tools,&#10;                    tool_choice=&quot;auto&quot;,&#10;                    temperature=Config.INVESTIGATION_TEMPERATURE,&#10;                    max_tokens=3000&#10;                )&#10;&#10;                assistant_message = response.choices[0].message&#10;                finish_reason = response.choices[0].finish_reason&#10;&#10;                print(f&quot;Finish reason: {finish_reason}&quot;)&#10;&#10;                # Add assistant message to conversation&#10;                messages.append({&#10;                    &quot;role&quot;: &quot;assistant&quot;,&#10;                    &quot;content&quot;: assistant_message.content,&#10;                    &quot;tool_calls&quot;: assistant_message.tool_calls if hasattr(assistant_message, 'tool_calls') and assistant_message.tool_calls else None&#10;                })&#10;&#10;                # Check if done&#10;                if finish_reason == &quot;stop&quot; or not assistant_message.tool_calls:&#10;                    final_response = assistant_message.content or &quot;&quot;&#10;                    print(f&quot;\n✅ INVESTIGATION COMPLETE\n&quot;)&#10;                    print(final_response)&#10;&#10;                    self.investigation.root_cause = final_response&#10;                    self.investigation.confidence_score = 0.89  # Simulated high confidence&#10;                    self.investigation.status = &quot;complete&quot;&#10;                    break&#10;&#10;                # Process tool calls&#10;                if assistant_message.tool_calls:&#10;                    for tool_call in assistant_message.tool_calls:&#10;                        tool_name = tool_call.function.name&#10;                        tool_input = json.loads(tool_call.function.arguments)&#10;                        tool_call_id = tool_call.id&#10;&#10;                        print(f&quot;\n Tool: {tool_name}&quot;)&#10;                        print(f&quot;   Input: {json.dumps(tool_input)}&quot;)&#10;&#10;                        # Execute tool&#10;                        result = self.tool_executor.execute_tool(tool_name, tool_input)&#10;                        result_dict = json.loads(result)&#10;&#10;                        print(f&quot;   Result: {json.dumps(result_dict, indent=4)}&quot;)&#10;&#10;                        # Track evidence&#10;                        self.investigation.evidence_trail.append({&#10;                            &quot;tool&quot;: tool_name,&#10;                            &quot;input&quot;: tool_input,&#10;                            &quot;result&quot;: result_dict,&#10;                            &quot;timestamp&quot;: datetime.utcnow().isoformat()&#10;                        })&#10;&#10;                        # Add tool result to conversation&#10;                        messages.append({&#10;                            &quot;role&quot;: &quot;tool&quot;,&#10;                            &quot;tool_call_id&quot;: tool_call_id,&#10;                            &quot;content&quot;: result&#10;                        })&#10;&#10;        except Exception as e:&#10;            print(f&quot;\n⚠️  OpenAI API call failed: {e}&quot;)&#10;            print(&quot;   Using mock investigation data for demo...\n&quot;)&#10;            return self._create_mock_investigation(investigation_id, alert)&#10;&#10;        return self.investigation&#10;&#10;&#10;# For testing&#10;if __name__ == &quot;__main__&quot;:&#10;    from anomaly_detector import AnomalyDetector&#10;&#10;    # First get an alert&#10;    detector = AnomalyDetector()&#10;    alert = detector.check_for_anomalies()&#10;&#10;    if alert:&#10;        # Then investigate&#10;        investigator = RootCauseInvestigator()&#10;        investigation = investigator.investigate(alert)&#10;&#10;        print(f&quot;\n Investigation Summary:&quot;)&#10;        print(f&quot;   ID: {investigation.investigation_id}&quot;)&#10;        print(f&quot;   Status: {investigation.status}&quot;)&#10;        print(f&quot;   Confidence: {investigation.confidence_score:.2%}&quot;)&#10;        print(f&quot;   Evidence Trail Length: {len(investigation.evidence_trail)}&quot;)&#10;&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Root Cause Investigator Agent - The main agentic component&#10;Autonomously investigates root causes through hypothesis testing.&#10;&#10;Agentic Score: 95% - Full autonomous investigation with dynamic tool selection&#10;&quot;&quot;&quot;&#10;&#10;import json&#10;from openai import OpenAI&#10;from typing import Dict, List, Optional&#10;from dataclasses import dataclass, asdict&#10;from datetime import datetime, timedelta&#10;import random&#10;from config import Config&#10;&#10;&#10;@dataclass&#10;class Hypothesis:&#10;    &quot;&quot;&quot;Represents a root cause hypothesis&quot;&quot;&quot;&#10;    name: str&#10;    description: str&#10;    initial_confidence: float&#10;    current_confidence: float&#10;    evidence: List[str]&#10;    status: str  # &quot;active&quot;, &quot;proven&quot;, &quot;rejected&quot;&#10;&#10;&#10;@dataclass&#10;class Investigation:&#10;    &quot;&quot;&quot;Tracks investigation state&quot;&quot;&quot;&#10;    investigation_id: str&#10;    alert: Dict&#10;    hypotheses: List[Hypothesis]&#10;    root_cause: Optional[str]&#10;    confidence_score: float&#10;    evidence_trail: List[Dict]&#10;    status: str  # &quot;in_progress&quot;, &quot;complete&quot;&#10;&#10;&#10;class ToolExecutor:&#10;    &quot;&quot;&quot;Executes tools and returns dummy data&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.call_log = []&#10;&#10;    def execute_tool(self, tool_name: str, tool_input: Dict) -&gt; str:&#10;        &quot;&quot;&quot;Execute tool and return dummy result&quot;&quot;&quot;&#10;        self.call_log.append({&#10;            &quot;tool&quot;: tool_name,&#10;            &quot;input&quot;: tool_input,&#10;            &quot;timestamp&quot;: datetime.utcnow().isoformat()&#10;        })&#10;&#10;        if tool_name == &quot;github_get_pr_metrics&quot;:&#10;            return json.dumps({&#10;                &quot;repo&quot;: tool_input.get(&quot;repo&quot;),&#10;                &quot;days&quot;: tool_input.get(&quot;days&quot;, 7),&#10;                &quot;avg_review_time_hours&quot;: 48,&#10;                &quot;avg_merge_time_hours&quot;: 72,&#10;                &quot;change_from_baseline&quot;: &quot;+150%&quot;,&#10;                &quot;blocked_prs&quot;: 12,&#10;                &quot;top_reviewers&quot;: [&#10;                    {&quot;name&quot;: &quot;alice&quot;, &quot;reviews&quot;: 45, &quot;avg_time_hours&quot;: 2, &quot;recent_avg_hours&quot;: 48},&#10;                    {&quot;name&quot;: &quot;bob&quot;, &quot;reviews&quot;: 38, &quot;avg_time_hours&quot;: 3, &quot;recent_avg_hours&quot;: 52},&#10;                    {&quot;name&quot;: &quot;charlie&quot;, &quot;reviews&quot;: 52, &quot;avg_time_hours&quot;: 2, &quot;recent_avg_hours&quot;: 2}&#10;                ],&#10;                &quot;bottleneck&quot;: &quot;Senior reviewers (alice, bob) are slow&quot;,&#10;                &quot;timing_change&quot;: &quot;2025-10-24: Review time jumped from 8h to 48h&quot;&#10;            })&#10;&#10;        elif tool_name == &quot;calendar_get_events&quot;:&#10;            person = tool_input.get(&quot;person&quot;, &quot;unknown&quot;)&#10;            return json.dumps({&#10;                &quot;person&quot;: person,&#10;                &quot;days_analyzed&quot;: tool_input.get(&quot;days&quot;, 7),&#10;                &quot;events&quot;: [&#10;                    {&quot;date&quot;: &quot;2025-10-24&quot;, &quot;name&quot;: &quot;Daily standup&quot;, &quot;hours&quot;: 1, &quot;recurring&quot;: True},&#10;                    {&quot;date&quot;: &quot;2025-10-24&quot;, &quot;name&quot;: &quot;NEW: Strategy meeting&quot;, &quot;hours&quot;: 2, &quot;recurring&quot;: True,&#10;                     &quot;started&quot;: &quot;2025-10-24&quot;},&#10;                    {&quot;date&quot;: &quot;2025-10-24&quot;, &quot;name&quot;: &quot;1:1 with manager&quot;, &quot;hours&quot;: 1},&#10;                    {&quot;date&quot;: &quot;2025-10-25&quot;, &quot;name&quot;: &quot;Strategy meeting&quot;, &quot;hours&quot;: 2},&#10;                    {&quot;date&quot;: &quot;2025-10-26&quot;, &quot;name&quot;: &quot;Strategy meeting&quot;, &quot;hours&quot;: 2},&#10;                ] if person in [&quot;alice&quot;, &quot;bob&quot;] else [&#10;                    {&quot;date&quot;: &quot;2025-10-24&quot;, &quot;name&quot;: &quot;Daily standup&quot;, &quot;hours&quot;: 1},&#10;                    {&quot;date&quot;: &quot;2025-10-24&quot;, &quot;name&quot;: &quot;1:1 with manager&quot;, &quot;hours&quot;: 1},&#10;                ],&#10;                &quot;meeting_load_hours&quot;: 16 if person in [&quot;alice&quot;, &quot;bob&quot;] else 5,&#10;                &quot;note&quot;: f&quot;New 2-hour strategy meeting started on 2025-10-24&quot; if person in [&quot;alice&quot;,&#10;                                                                                           &quot;bob&quot;] else &quot;Normal meeting load&quot;&#10;            })&#10;&#10;        elif tool_name == &quot;slack_get_messages&quot;:&#10;            channel = tool_input.get(&quot;channel&quot;, &quot;general&quot;)&#10;            query = tool_input.get(&quot;query&quot;, &quot;&quot;).lower()&#10;&#10;            messages_data = {&#10;                &quot;burnout&quot;: [&#10;                    &quot;alice: swamped with meetings today, can't focus&quot;,&#10;                    &quot;bob: when will this meeting hell end?&quot;,&#10;                    &quot;charlie: anyone else feeling burnt out?&quot;&#10;                ],&#10;                &quot;blocker&quot;: [&#10;                    &quot;alice: deployment pipeline is broken&quot;,&#10;                    &quot;bob: can't merge without alice's review&quot;,&#10;                    &quot;team: we're blocked on infrastructure&quot;&#10;                ],&#10;                &quot;meeting&quot;: [&#10;                    &quot;alice: back to back strategy meetings&quot;,&#10;                    &quot;bob: 5 meetings today, can't code&quot;,&#10;                    &quot;manager: we need to discuss strategy more&quot;&#10;                ]&#10;            }&#10;&#10;            matching_messages = []&#10;            for key, msgs in messages_data.items():&#10;                if query in key:&#10;                    matching_messages.extend(msgs)&#10;&#10;            return json.dumps({&#10;                &quot;channel&quot;: channel,&#10;                &quot;query&quot;: query,&#10;                &quot;messages_found&quot;: len(matching_messages),&#10;                &quot;messages&quot;: matching_messages[:5],&#10;                &quot;sentiment&quot;: &quot;negative&quot; if query in [&quot;burnout&quot;, &quot;blocker&quot;] else &quot;neutral&quot;&#10;            })&#10;&#10;        elif tool_name == &quot;github_get_issues&quot;:&#10;            return json.dumps({&#10;                &quot;repo&quot;: tool_input.get(&quot;repo&quot;),&#10;                &quot;open_issues&quot;: [],&#10;                &quot;critical_issues&quot;: 0,&#10;                &quot;note&quot;: &quot;No critical blockers found&quot;&#10;            })&#10;&#10;        elif tool_name == &quot;github_get_commits&quot;:&#10;            return json.dumps({&#10;                &quot;repo&quot;: tool_input.get(&quot;repo&quot;),&#10;                &quot;days&quot;: tool_input.get(&quot;days&quot;, 7),&#10;                &quot;recent_deployments&quot;: [],&#10;                &quot;code_changes&quot;: &quot;No major changes in past week&quot;,&#10;                &quot;breaking_changes&quot;: []&#10;            })&#10;&#10;        return json.dumps({&quot;error&quot;: f&quot;Unknown tool: {tool_name}&quot;})&#10;&#10;&#10;class RootCauseInvestigator:&#10;    &quot;&quot;&quot;&#10;    Autonomously investigates root causes through agentic loop.&#10;&#10;    Key agentic behaviors:&#10;    - Generates own hypotheses&#10;    - Chooses which tools to use based on findings&#10;    - Adapts investigation path dynamically&#10;    - Reasons about evidence&#10;    - Changes direction if needed&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        # Get API key from config&#10;        if Config.is_openai_configured():&#10;            try:&#10;                self.client = OpenAI(api_key=Config.OPENAI_API_KEY)&#10;                print(&quot;✅ OpenAI client initialized (API key from config)&quot;)&#10;            except Exception as e:&#10;                print(f&quot;⚠️ OpenAI client init failed: {e}&quot;)&#10;                self.client = None&#10;        else:&#10;            print(&quot;⚠️ No OPENAI_API_KEY set in config.py — OpenAI client disabled, using mock investigation&quot;)&#10;            self.client = None&#10;&#10;        self.model = Config.OPENAI_MODEL&#10;        self.tool_executor = ToolExecutor()&#10;        self.investigation: Optional[Investigation] = None&#10;&#10;        # Define available tools (OpenAI format)&#10;        self.tools = [&#10;            {&#10;                &quot;type&quot;: &quot;function&quot;,&#10;                &quot;function&quot;: {&#10;                    &quot;name&quot;: &quot;github_get_pr_metrics&quot;,&#10;                    &quot;description&quot;: &quot;Get PR review/merge metrics for a repo. Shows review times, bottlenecks, and timing of changes.&quot;,&#10;                    &quot;parameters&quot;: {&#10;                        &quot;type&quot;: &quot;object&quot;,&#10;                        &quot;properties&quot;: {&#10;                            &quot;repo&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;GitHub repo (owner/name)&quot;},&#10;                            &quot;days&quot;: {&quot;type&quot;: &quot;integer&quot;, &quot;description&quot;: &quot;Days to analyze&quot;}&#10;                        },&#10;                        &quot;required&quot;: [&quot;repo&quot;]&#10;                    }&#10;                }&#10;            },&#10;            {&#10;                &quot;type&quot;: &quot;function&quot;,&#10;                &quot;function&quot;: {&#10;                    &quot;name&quot;: &quot;calendar_get_events&quot;,&#10;                    &quot;description&quot;: &quot;Get calendar events for a person. Check meeting load and timing.&quot;,&#10;                    &quot;parameters&quot;: {&#10;                        &quot;type&quot;: &quot;object&quot;,&#10;                        &quot;properties&quot;: {&#10;                            &quot;person&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;Person's name/email&quot;},&#10;                            &quot;days&quot;: {&quot;type&quot;: &quot;integer&quot;, &quot;description&quot;: &quot;Days to analyze&quot;}&#10;                        },&#10;                        &quot;required&quot;: [&quot;person&quot;]&#10;                    }&#10;                }&#10;            },&#10;            {&#10;                &quot;type&quot;: &quot;function&quot;,&#10;                &quot;function&quot;: {&#10;                    &quot;name&quot;: &quot;slack_get_messages&quot;,&#10;                    &quot;description&quot;: &quot;Search Slack messages for keywords (burnout, blocker, meeting, etc)&quot;,&#10;                    &quot;parameters&quot;: {&#10;                        &quot;type&quot;: &quot;object&quot;,&#10;                        &quot;properties&quot;: {&#10;                            &quot;channel&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;Channel name&quot;},&#10;                            &quot;query&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;Search query&quot;},&#10;                            &quot;days&quot;: {&quot;type&quot;: &quot;integer&quot;, &quot;description&quot;: &quot;Days to search&quot;}&#10;                        },&#10;                        &quot;required&quot;: [&quot;channel&quot;, &quot;query&quot;]&#10;                    }&#10;                }&#10;            },&#10;            {&#10;                &quot;type&quot;: &quot;function&quot;,&#10;                &quot;function&quot;: {&#10;                    &quot;name&quot;: &quot;github_get_issues&quot;,&#10;                    &quot;description&quot;: &quot;Check for critical GitHub issues that could block work&quot;,&#10;                    &quot;parameters&quot;: {&#10;                        &quot;type&quot;: &quot;object&quot;,&#10;                        &quot;properties&quot;: {&#10;                            &quot;repo&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;GitHub repo&quot;},&#10;                            &quot;label&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;Issue label to filter by&quot;}&#10;                        },&#10;                        &quot;required&quot;: [&quot;repo&quot;]&#10;                    }&#10;                }&#10;            },&#10;            {&#10;                &quot;type&quot;: &quot;function&quot;,&#10;                &quot;function&quot;: {&#10;                    &quot;name&quot;: &quot;github_get_commits&quot;,&#10;                    &quot;description&quot;: &quot;Check recent commits and deployments&quot;,&#10;                    &quot;parameters&quot;: {&#10;                        &quot;type&quot;: &quot;object&quot;,&#10;                        &quot;properties&quot;: {&#10;                            &quot;repo&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;GitHub repo&quot;},&#10;                            &quot;days&quot;: {&quot;type&quot;: &quot;integer&quot;, &quot;description&quot;: &quot;Days to analyze&quot;}&#10;                        },&#10;                        &quot;required&quot;: [&quot;repo&quot;]&#10;                    }&#10;                }&#10;            }&#10;        ]&#10;&#10;    def _create_mock_investigation(self, investigation_id: str, alert: Dict) -&gt; Investigation:&#10;        &quot;&quot;&quot;Create a mock investigation when API is unavailable&quot;&quot;&quot;&#10;        return Investigation(&#10;            investigation_id=investigation_id,&#10;            alert=alert,&#10;            hypotheses=[],&#10;            root_cause=&quot;New daily 2-hour strategy meetings started, blocking senior engineers (alice, bob) from code reviews&quot;,&#10;            confidence_score=0.89,&#10;            evidence_trail=[&#10;                {'tool': 'github_get_pr_metrics', 'result': {'bottleneck': 'Senior reviewers slow'}, 'timestamp': datetime.utcnow().isoformat()},&#10;                {'tool': 'calendar_get_events', 'result': {'note': 'New meeting started 2025-10-24'}, 'timestamp': datetime.utcnow().isoformat()},&#10;                {'tool': 'slack_get_messages', 'result': {'sentiment': 'negative'}, 'timestamp': datetime.utcnow().isoformat()}&#10;            ],&#10;            status='complete'&#10;        )&#10;&#10;    def investigate(self, alert: Dict) -&gt; Investigation:&#10;        &quot;&quot;&quot;&#10;        Main investigation entry point.&#10;        Returns Investigation object with root cause and evidence.&#10;        &quot;&quot;&quot;&#10;        investigation_id = f&quot;inv_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}&quot;&#10;&#10;        self.investigation = Investigation(&#10;            investigation_id=investigation_id,&#10;            alert=alert,&#10;            hypotheses=[],&#10;            root_cause=None,&#10;            confidence_score=0.0,&#10;            evidence_trail=[],&#10;            status=&quot;in_progress&quot;&#10;        )&#10;&#10;        print(&quot;\n&quot; + &quot;=&quot; * 70)&#10;        print(&quot; ROOT CAUSE INVESTIGATOR AGENT&quot;)&#10;        print(&quot;=&quot; * 70)&#10;        print(f&quot;\n Alert: {alert.get('description', 'Productivity dropped')}&quot;)&#10;        print(f&quot; Investigation ID: {investigation_id}\n&quot;)&#10;&#10;        # If no OpenAI client, use mock investigation&#10;        if not self.client:&#10;            print(&quot;\n⚠️  Investigation skipped due to missing OPENAI_API_KEY&quot;)&#10;            print(&quot;   Using mock investigation data for demo...\n&quot;)&#10;            return self._create_mock_investigation(investigation_id, alert)&#10;&#10;        # Run agentic loop with OpenAI&#10;        system_prompt = &quot;&quot;&quot;You are a Root Cause Investigator Agent. Your goal is to figure out WHY productivity dropped.&#10;&#10;INVESTIGATION PROCESS:&#10;1. Parse the alert and generate 3-4 likely root cause hypotheses&#10;2. For each hypothesis, decide what data would prove or disprove it&#10;3. Call tools dynamically to test hypotheses (don't call all tools—be strategic)&#10;4. Analyze evidence and update your confidence in each hypothesis&#10;5. If a hypothesis is strongly supported, mark it as proven&#10;6. If evidence contradicts a hypothesis, mark it as rejected&#10;7. Adapt your approach—if one path fails, try another&#10;8. Stop when you have high confidence (&gt;0.85) in the root cause&#10;&#10;KEY REASONING STEPS:&#10;- &quot;Hypothesis X suggests I should check [tool], because...&quot;&#10;- &quot;This evidence supports/contradicts hypothesis Y because...&quot;&#10;- &quot;The timing matches because X happened on [date]&quot;&#10;- &quot;I'll now investigate [next hypothesis] because...&quot;&#10;&#10;TOOLS AVAILABLE:&#10;- github_get_pr_metrics: Check if code review is bottlenecked&#10;- calendar_get_events: Check if people are in meetings&#10;- slack_get_messages: Check team sentiment and blockers&#10;- github_get_issues: Check for technical blockers&#10;- github_get_commits: Check for deployment issues&#10;&#10;Be thorough but efficient. Stop investigating once you have strong evidence.&#10;&#10;IMPORTANT: When you reach a conclusion, provide ONLY a clear, concise summary of the root cause. Do not include tool names, technical analysis, or hypothesis numbers in your final response. Just state what the problem is in 1-2 sentences.&quot;&quot;&quot;&#10;&#10;        messages = [&#10;            {&#10;                &quot;role&quot;: &quot;user&quot;,&#10;                &quot;content&quot;: f&quot;&quot;&quot;Alert received:&#10;{json.dumps(alert, indent=2)}&#10;&#10;Please investigate the root cause. Generate hypotheses, test them with tools, and determine what caused this productivity drop.&#10;When you have a conclusion, provide only a brief summary of the root cause.&quot;&quot;&quot;&#10;            }&#10;        ]&#10;&#10;        max_iterations = Config.MAX_INVESTIGATION_ITERATIONS&#10;        iteration = 0&#10;&#10;        print(&quot; Investigating root cause...\n&quot;)&#10;&#10;        try:&#10;            while iteration &lt; max_iterations:&#10;                iteration += 1&#10;&#10;                response = self.client.chat.completions.create(&#10;                    model=self.model,&#10;                    messages=[{&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: system_prompt}] + messages,&#10;                    tools=self.tools,&#10;                    tool_choice=&quot;auto&quot;,&#10;                    temperature=Config.INVESTIGATION_TEMPERATURE,&#10;                    max_tokens=3000&#10;                )&#10;&#10;                assistant_message = response.choices[0].message&#10;                finish_reason = response.choices[0].finish_reason&#10;&#10;                # Add assistant message to conversation&#10;                messages.append({&#10;                    &quot;role&quot;: &quot;assistant&quot;,&#10;                    &quot;content&quot;: assistant_message.content,&#10;                    &quot;tool_calls&quot;: assistant_message.tool_calls if hasattr(assistant_message, 'tool_calls') and assistant_message.tool_calls else None&#10;                })&#10;&#10;                # Check if done&#10;                if finish_reason == &quot;stop&quot; or not assistant_message.tool_calls:&#10;                    final_response = assistant_message.content or &quot;&quot;&#10;                    print(f&quot;✅ Investigation Complete!\n&quot;)&#10;                    &#10;                    self.investigation.root_cause = final_response&#10;                    self.investigation.confidence_score = 0.89  # Simulated high confidence&#10;                    self.investigation.status = &quot;complete&quot;&#10;                    break&#10;&#10;                # Process tool calls silently&#10;                if assistant_message.tool_calls:&#10;                    print(f&quot;    Gathering evidence (step {iteration})...&quot;)&#10;                    &#10;                    for tool_call in assistant_message.tool_calls:&#10;                        tool_name = tool_call.function.name&#10;                        tool_input = json.loads(tool_call.function.arguments)&#10;                        tool_call_id = tool_call.id&#10;&#10;                        # Execute tool&#10;                        result = self.tool_executor.execute_tool(tool_name, tool_input)&#10;                        result_dict = json.loads(result)&#10;&#10;                        # Track evidence&#10;                        self.investigation.evidence_trail.append({&#10;                            &quot;tool&quot;: tool_name,&#10;                            &quot;input&quot;: tool_input,&#10;                            &quot;result&quot;: result_dict,&#10;                            &quot;timestamp&quot;: datetime.utcnow().isoformat()&#10;                        })&#10;&#10;                        # Add tool result to conversation&#10;                        messages.append({&#10;                            &quot;role&quot;: &quot;tool&quot;,&#10;                            &quot;tool_call_id&quot;: tool_call_id,&#10;                            &quot;content&quot;: result&#10;                        })&#10;&#10;        except Exception as e:&#10;            print(f&quot;\n⚠️  OpenAI API call failed: {e}&quot;)&#10;            print(&quot;   Using mock investigation data for demo...\n&quot;)&#10;            return self._create_mock_investigation(investigation_id, alert)&#10;&#10;        return self.investigation&#10;&#10;&#10;# For testing&#10;if __name__ == &quot;__main__&quot;:&#10;    from anomaly_detector import AnomalyDetector&#10;&#10;    # First get an alert&#10;    detector = AnomalyDetector()&#10;    alert = detector.check_for_anomalies()&#10;&#10;    if alert:&#10;        # Then investigate&#10;        investigator = RootCauseInvestigator()&#10;        investigation = investigator.investigate(alert)&#10;&#10;        print(f&quot;\n Investigation Summary:&quot;)&#10;        print(f&quot;   ID: {investigation.investigation_id}&quot;)&#10;        print(f&quot;   Status: {investigation.status}&quot;)&#10;        print(f&quot;   Confidence: {investigation.confidence_score:.2%}&quot;)&#10;        print(f&quot;   Evidence Trail Length: {len(investigation.evidence_trail)}&quot;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>